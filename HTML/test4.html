<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Test4测试</title>
    <style>
        .highLight {
            padding: 2px 5px;
            background: #08bcd4;
            color: white;
        }
    </style>
</head>

<body>

    <script>
        //ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
        //Set 本身是一个构造函数，用来生成 Set 数据结构。
        // const s = new Set();
        // [1, 2, 2, 2, 3, 3, 4].forEach(x => s.add(x));
        // for (let i of s) {
        //     console.log(i);
        // }
        // let arry = Array.from(s);
        // console.log(arry);
        //  set数据结构中数据不会发生类型转换 比如 5 不等于 '5'  但是 NaN等于NaN


        //提供了去数组重复的好方法
        // function dedupe(arry) {
        //     return Array.from(new Set(arry));
        // }
        // let test = dedupe([1, 1, 2, 3, 2, 5, 4]);
        // console.log(test);

        // // Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）
        // let a = new Set([1, 2, 3]);
        // let b = new Set([4, 3, 2]);
        // // 并集
        // let union = new Set([...a, ...b]);
        // // Set {1, 2, 3, 4}
        // // 交集
        // let intersect = new Set([...a].filter(x => b.has(x)));
        // // set {2, 3}
        // // 差集
        // let difference = new Set([...a].filter(x => !b.has(x)));
        // // Set {1}

        //WeakSet

        //map对象
        //Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，
        //我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名
        // const map = new Map();
        // let a = ['a']
        // map.set(a, 555);
        // console.log(map.get(a));

        //Map结构转化为数组结构最快的方法就是使用扩展运算符
        // const map = new Map([
        //     ['name', 'junjun'],
        //     ['age', 22],
        //     ['sex', 'man']
        // ])
        // console.log([...map.keys()]);
        // console.log([...map.values()]);
        // console.log([...map]);

        //数组的map方法与filter方法使用
        //map类似与遍历之后返回， filter则是过滤
        // let arry = [1, 2, 4, 9, 8, 10];
        // let arry_1 = arry.map(function(item, index) {
        //     if (item % 2) {
        //         return item;
        //     }
        // });
        // let arry_2 = arry.filter((item) => item < 5);
        // console.log(arry_1);
        // console.log(arry_2);

        // const map0 = new Map()
        //     .set(1, 'a')
        //     .set(2, 'b')
        //     .set(3, 'c');
        // let s = [...map0].filter(([k, v]) => k < 3);
        // console.log(s);

        // function timeout(ms) {
        //     return new Promise((resolve, reject) => {
        //         setTimeout(resolve, ms, 'done');
        //     });
        // }
        // timeout(100).then((value) => {
        //     console.log(value);
        // });

        // const Person = {
        //     name: 'Jelly',
        //     habits: ['coding', 'sleeping', 'reading'],
        //     printHabits: function() {
        //         this.habits.map(habit => {
        //             console.log(`${this.name} loves ${habit}`); //箭头函数的this指向父作用于的this
        //         })
        //     }

        // }
        // Person.printHabits();

        //标签模板字符串
        function highLigt(strs, ...values) {
            const highLigted = values.map(value => {
                    return `<span class = 'highLight'>${value}</span>`
                })
                // let str = '';
            return strs.reduce((pre, curr, i) => {
                    return `${pre}${curr}${highLigted[i] || ''}`
                }, '')
                // strs.forEach((string, i) => str += `${string}${highLigted[i] || ''}`);
                // return str;
        }
        const user = 'Marry';
        const word = 'That is perfect!';
        const setence = highLigt `${user} is a good girl.${word}`;
        document.body.innerHTML = setence;
    </script>
</body>

</html>